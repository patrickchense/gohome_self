##简介
[github上关于high performance go的笔记](https://talks.godoc.org/github.com/davecheney/high-performance-go-workshop/high-performance-go-workshop.slide#10)

##性能关注
* CPU
* MEMORY
* IO/NETWORK

##性能指标
benchmark 测试：
代码: fib/fib.go 和 fib/fib_test.go
```text
-bash-3.2$ go test -bench=. ./fib
goos: darwin
goarch: amd64
pkg: gohome_self/learnGoInternals/fib
BenchmarkFib-4   	   30000	     51517 ns/op
PASS
ok  	gohome_self/learnGoInternals/fib	2.069s
```
```text
go test -run=^$ -bench=. bufio
go test -run=^$ -bench=. -benchmem bufio
```

##performance measurement & profiling
[pprof tools](https://github.com/gperftools/gperftools)
* runtime/pprof package build in Go
* go tool工具investigate profiles
pprof 支持的profiling 类型
* CPU
* Memory
* Block

CPU profiling 常用，一旦enabled, 每10ms记录一次当前运行的goroutines的stack trace
当profiling完成，可以分析判断真正的code path
当一个func出现的次数越多，那个code path在结果中占据的比例就大

Memory profiling记录heap allocation时候的stack trace
stack allocations是认为自由的，不会再memory profiling中记录的
Memory profiling和CPU是一样取样的，默认1/1000的比列，可以自己调整
通常认为用memroy profiling不是一个查找memroy leak的好手段

Block profiling，记录goroutine用来等待获取资源的时间
用来判断并发瓶颈好用
Block的类型包括：
* 发送或接收一个没有缓存的channel
* 发送到一个full channel，或从一个空channel接收
* 尝试lock一个sync.Mutex，这个锁被其他goroutine锁了

每次只能使用一个profiling，并且profiling会对程序产生负载

###使用
```text
go tool pprof /path/to/your/binary /path/to/your/profile
```
The binary argument must be the binary that produced this profile.
The profile argument must be the profile generated by this binary.

延伸阅读: 
[Profiling Go programs](http://blog.golang.org/profiling-go-programs)
[Debugging performance issues in Go programs](https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs)

The output of a memory profile can be similarly visualised.
```text
% go build -gcflags='-memprofile=/tmp/m.p'
% go tool pprof --alloc_objects -svg $(go tool -n compile) /tmp/m.p > alloc_objects.svg
% go tool pprof --inuse_objects -svg $(go tool -n compile) /tmp/m.p > inuse_objects.svg
```

Here is a visualisation of a block profile:
```text
% go test -run=XXX -bench=ClientServer -blockprofile=/tmp/b.p net/http
% go tool pprof -svg http.test /tmp/b.p > block.svg
```

###profiling benchmarks
testing package支持生成CPU,Memory，Blcok profiling
* -cpuprofile=$FILE writes a CPU profile to $FILE.
* -memprofile=$FILE, writes a memory profile to $FILE, -memprofilerate=N adjusts the profile rate to 1/N.
* -blockprofile=$FILE, writes a block profile to $FILE.

Using any of these flags also preserves the binary.
```text
% go test -run=XXX -bench=. -cpuprofile=c.p bytes
% go tool pprof bytes.test c.p
```

###runtime profiling
runtime/pprof 包支持
这个包很底层，比较难使用


###Framepointers
在1.7发布了新的编译器支持amd64，默认启用了frame pointer
frame pointer是一个指向stack 最上层的寄存器
framepointer使go tool gdb, pref能了解go 调用过程(call stack)

###go tool trace
1.5中加入的工具
[execution trace profiling](https://golang.org/doc/go1.5#trace_command)
捕捉ns级别精度:
* goroutine creatiion/start/end
* goroutine blocking/unblocking
* network blocking
* system calls
* GC events

```text
% cd $(go env GOROOT)/test/bench/go1
% go test -bench=HTTPClientServer -trace=/tmp/t.p
```
结果:(trace)
```text
% go tool trace /tmp/t.p
2016/08/13 17:01:04 Parsing trace...
2016/08/13 17:01:04 Serializing trace...
2016/08/13 17:01:05 Splitting trace...
2016/08/13 17:01:06 Opening browser
```

##compiler optimisation
3个Go compiler的优化手段
* escape analysis
* Inlining
* Dead code elimination

###escape analysis



