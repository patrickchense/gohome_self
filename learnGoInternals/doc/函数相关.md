##defer函数
###坑
例1：
```go
func f() (result int) {
    defer func() {
        result++
    }()
    return 0
}
``` 
例2： 
```go
func f() (r int) {
     t := 5
     defer func() {
	   t = t + 5
     }()
     return t
}
```
例1结果不是0，例2结果不是10
defer在return之前执行，__最重要__ 的是 __return xxx这一条语句并不是一条原子指令__  
函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。
defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。
其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成
```go
返回值 = xxx
调用defer函数
空的return
```
###实现
跟go类似，不同的是调用了runtime.deferproc而不是runtime.newproc
在defer出现的地方，插入指令call runtime.deferproc, 然后在函数返回之前的地方，插入指令runtime.deferreturn
goroutine控制结构中，有一张记录defer，调用runtime.deferproc时会将需要的defer表达式记录在表中，而在调用runtime.deferreturn的时候，依次
从defer中出栈并执行



##连续栈
关于go routine，每个都会创建栈，初始栈很小，动态加大，所以go可以支持很多很多routine
1.3之后使用continuous stack
每次运行函数都会检查大小，不够用会"中断"， 然后分配一块足够大的空间把当前的内容拷贝到新栈中，然后继续
* 具体细节
1. 如何捕获栈空间不足
 GO和C不同，不使用栈指针寄存器和栈基址寄存器确定函数的栈，而是通过goroutine对应的结构体保存stackbase和stackguard，然后每次运行前几条指令
 ，先比较指针寄存器和stackguard，是否溢出
 